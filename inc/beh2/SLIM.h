/*
 * ************************************************************************************* SLIM (Stateflow Language IMplementation) *************************************************************************************
 * This library provides a way to define a hierarchical state machine (OR decomposition). A hierarchical state machine is seen as a collection of states, each of which is again a state machine on its own. Moreover,
 * events that are dispatched to a state machine - at whichever level it is - are also dispatched to the currently active state; as the latter is again a state machine, events propagate downwards in the hierarchy.
 * This is exactly how Stateflow manages events, according to a semantic that is the opposite of that adopted by UML. The main advantage is that this solution doesn't need any dynamic binding of methods, because
 * state is not a polymorphic entity anymore.
 * This version is based on the 'double-switch' pattern, turned into a 'triple-switch' one to manage multiple state machines (super-states), and only supports OR decomposition.
 * Author: Alessandro Trifoglio
 */

#ifndef SLIM_LANGUAGE_H
#define SLIM_LANGUAGE_H

#include "../rt_types.h"

#define SEND(E, ME) dispatch ((ME), (E))

/* Pseudo-language to define state machines. Example: the code

	void dispatch (State* me, const Event e) {
		switch (me->id) {
			case STATE_UP1:
				switch (me->state->id) {
					case STATE_1:
						switch (e) {
							case event_1:
								if (x==0) tran(me, e, &state_2, EXTERNAL, &act_1);
								else if (!me->state->isLeaf) dispatch (me->state, e);
								break;
							case event_2:
								if (true) tran(me, e, &state_3, EXTERNAL, &act_2);
								else if (!me->state->isLeaf) dispatch (me->state, e);
								break;
							default: if (!me->state->isLeaf) dispatch (me->state, e);
						}
						break;
					case STATE_2:
						switch (e) {
							case event_1:
								if (true) tran(me, e, &state_4, EXTERNAL, &act_3);
								else if (!me->state->isLeaf) dispatch (me->state, e);
								break;
							default: if (!me->state->isLeaf) dispatch (me->state, e);
						}
						break;
				}
				break;
			case STATE_UP2:
				switch (me->state->id) {
					case STATE_7:
						switch (e) {
							case event_1:
								if (x==0) tran(me, e, &state_8, EXTERNAL, &act_7);
								else if (!me->state->isLeaf) dispatch (me->state, e);
								break;
							case event_2:
								if (true) tran(me, e, &state_9, EXTERNAL, &act_8);
								else if (!me->state->isLeaf) dispatch (me->state, e);
								break;
							default: if (!me->state->isLeaf) dispatch (me->state, e);
						}
						break;
					case STATE_8:
						switch (e) {
							case event_1:
								if (true) tran(me, e, &state_9, EXTERNAL, &act_9);
								else if (!me->state->isLeaf) dispatch (me->state, e);
								break;
							default: if (!me->state->isLeaf) dispatch (me->state, e);
						}
						break;
				}
				break;
			default: break;
		}
	}

	can be generated by this pseudo-code

	START_SM
		START_HIERARCHICAL (STATE_UP1)
			START_STATE (STATE_1)
				WHEN (event_1) IF (x==0) UPDATE_TO (&state_2, EXTERNAL, &act_1)
				WHEN (event_2) ALWAYS UPDATE_TO (&state_3, EXTERNAL, &act_2)
			END_STATE
			START_STATE (STATE_2)
				WHEN (event_1) ALWAYS UPDATE_TO (&state_4, EXTERNAL, &act_3)
			END_STATE
		END_HIERARCHICAL;
		START_HIERARCHICAL (STATE_UP2)
			START_STATE (STATE_7)
				WHEN (event_1) IF (x<0) UPDATE_TO (&state_8, EXTERNAL, &act_7)
				WHEN (event_2) ALWAYS UPDATE_TO (&state_9, EXTERNAL, &act_8)
			END_STATE
			START_STATE (STATE_8)
				WHEN (event_1) ALWAYS UPDATE_TO (&state_9, EXTERNAL, &act_9)
			END_STATE
		END_HIERARCHICAL;
	END_SM

*/

#define START_SM 																	\
void dispatch (State* me, const unsigned int e) { 									\
	switch (me->id) { 																\

#define START_HIERARCHICAL(STATE) 													\
		case STATE: 																\
			switch (me->state->id) { 												\

#define START_STATE(STATE) 															\
				case STATE: 														\
					switch (e) { 													\

#define WHEN(EVENT) 																\
						case EVENT: 												\

#define IF(GUARD) 																	\
							if (GUARD) 												\

#define ALWAYS 																		\
							if (true) 												\

#define UPDATE_TO(STATE, MODE, ACTION) 												\
								tran(me, e, STATE, MODE, ACTION); 					\
							else if (!me->state->isLeaf) 							\
								dispatch (me->state, e); 							\
							break; 													\

#define END_STATE 																	\
						default: if (!me->state->isLeaf) dispatch (me->state, e); 	\
					} 																\
					break;

#define END_HIERARCHICAL 															\
			} 																		\
			break;

#define END_SM 																		\
		default: break; 															\
	} 																				\
}

/* --------------------------------------------------------- Types --------------------------------------------------------- */

/* Type of transition: internal transitions doesn't trigger 'entry' and 'exit' actions */

typedef enum TransitionMode {
	INTERNAL, EXTERNAL
} TransitionMode;

/* Actions produced by transitions */

typedef void (*Action)();

/* Structured state: in general, a super-state with a currently active internal state (OR decomposition), an initial state, a history etc. */

struct State {
	unsigned int id;
	struct State* parent;
	boolean isLeaf;
	boolean hasHistory;
	Action entryAction;
	Action exitAction;
	Action action_o;
	struct State* state_o;
	struct State* state;
};

typedef struct State State;

/* --------------------------------------------------------- Interface --------------------------------------------------------- */

void dispatch (State* me, const unsigned int e);
void tran (State* me, const unsigned int e, State* target, const TransitionMode mode, const Action action);

void init (State* me);

void voidAction ();

#endif /* SLIM_LANGUAGE_H */
